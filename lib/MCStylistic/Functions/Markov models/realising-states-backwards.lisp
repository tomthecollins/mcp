#| Copyright 2008-2013 Tom Collins
   Wednesday 1 September 2010
   Incomplete

\noindent These functions are used to convert states
generated using a backwards running Markov chain Monte
Carlo into datapoints. The functions have similar
versions in the files realising-states.lisp and
markov-compose.lisp.

; REQUIRED PACKAGES:
; (in-package :common-lisp-user)
(load
 (merge-pathnames
  (make-pathname
   :directory '(:relative "Maths foundation")
   :name "list-processing"
   :type "lisp")
  *MCStylistic-MonthYear-functions-path*))
(load
 (merge-pathnames
  (make-pathname
   :directory '(:relative "Markov models")
   :name "realising-states"
   :type "lisp")
  *MCStylistic-MonthYear-functions-path*))
(load
 (merge-pathnames
  (make-pathname
   :directory '(:relative "Maths foundation")
   :name "vector-operations"
   :type "lisp")
  *MCStylistic-MonthYear-functions-path*))
|#

#|
\noindent Example:
\begin{verbatim}
(setq
 states<-1
 '(((3 NIL) (NIL NIL "C-6-2" ((285 61 60 3 0 288 6))))
   ((2 (5 3 9))
    (17 10 "C-6-2"
     ((58 56 57 1 1 59 219) (58 61 60 1 1 59 220)
      (58 64 62 1 1 59 221)
      (58 73 67 3/2 0 119/2 222))))
   ((3/2 (3 9 14))
    (7 4 "C-7-2"
     ((120 50 54 1 1 121 351) (120 53 56 1 1 121 352)
      (120 62 61 1 1 121 353)
      (241/2 76 69 1/2 0 121 355))))
   ((1 (3 9 15))
    (0 0 "C-7-2"
     ((120 50 54 1 1 121 351) (120 53 56 1 1 121 352)
      (120 62 61 1 1 121 353)
      (120 77 70 1/2 0 241/2 354))))
   ((7/2 (3 6 15))
    (-2 -1 "C-7-2"
     ((119 52 55 1 1 120 346) (119 55 57 1 1 120 347)
      (119 61 60 1 1 120 348)
      (239/2 76 69 1/2 0 120 350))))))
(setq
 states<-2
 '(((1 NIL)
    (NIL NIL "C-24-3" ((234 72 67 3 0 237 9))))
   ((3 "rest") (11 6 "C-7-2" NIL))
   ((2 (7 9 3 9))
    (NIL NIL "C-30-3"
         ((259 41 49 1 1 260 948)
          (259 48 53 1 1 260 949)
          (259 57 58 1 1 260 950)
          (259 60 60 1 0 260 951)
          (259 69 65 1 0 260 952))))
   ((5/3 (36 8))
    (12 7 "C-30-3"
        ((258 29 42 1 1 259 941)
         (776/3 65 63 1/3 0 259 946)
         (776/3 73 68 1/3 0 259 947))))
   ((4/3 (36 8))
    (0 0 "C-30-3"
       ((258 29 42 1 1 259 941)
        (775/3 65 63 1/3 0 776/3 944)
        (775/3 73 68 1/3 0 776/3 945))))))
(create-MIDI&morphetic-numbers<- states<-1 57 58)
(create-MIDI&morphetic-numbers<- states<-2 57 58)
--> (((7/2 (35 38 44 59) (45 47 50 59))
      (-2 -1 "C-7-2"
       ((119 52 55 1 1 120 346)
        (119 55 57 1 1 120 347)
        (119 61 60 1 1 120 348)
        (239/2 76 69 1/2 0 120 350))))
     ((1 (33 36 45 60) (44 46 51 60))
      (0 0 "C-7-2"
       ((120 50 54 1 1 121 351)
        (120 53 56 1 1 121 352)
        (120 62 61 1 1 121 353)
        (120 77 70 1/2 0 241/2 354))))
     ((3/2 (33 36 45 59) (44 46 51 59))
      (7 4 "C-7-2"
       ((120 50 54 1 1 121 351)
        (120 53 56 1 1 121 352)
        (120 62 61 1 1 121 353)
        (241/2 76 69 1/2 0 121 355))))
     ((2 (40 45 48 57) (48 51 53 58))
      (17 10 "C-6-2"
       ((58 56 57 1 1 59 219) (58 61 60 1 1 59 220)
        (58 64 62 1 1 59 221)
        (58 73 67 3/2 0 119/2 222))))
     ((3 (57) (58))
      (NIL NIL "C-6-2" ((285 61 60 3 0 288 6))))).
\end{verbatim}

\noindent This function is similar to the function
create-MIDI&morphetic-numbers. The difference is that
states generated by a backwards-running Markov model
are supplied as the argument, and the intervals
between bass notes refer to states $X_n$ and
$X_{n+1}$, rather than $X_n$ and $X_{n-1}$, so the
unpacking proceeds differently. The states are
reversed into temporal order at the end. |#

(defun create-MIDI&morphetic-numbers<-
       (states<- &optional (next-MIDI 60)
        (next-morphetic 60) (MIDI-step-index 0)
        (morphetic-step-index 1)
        (MNNs
         (nth-list-of-lists
          1 (fourth (second (first states<-)))))
        (MPNs
         (nth-list-of-lists
          2 (fourth (second (first states<-)))))
        (MNN-trans
         (if MNNs (- next-MIDI (first MNNs))))
        (MPN-trans
         (if MPNs
           (- next-morphetic (first MPNs))))
        (bass-step-MIDI
	 (if (null
              (nth
               MIDI-step-index
               (second (first states<-))))
	   (identity 0)
	   (nth
            MIDI-step-index
            (second (first states<-)))))
        (bass-step-morphetic
	 (if (null
              (nth
               morphetic-step-index
               (second (first states<-))))
	   (identity 0)
	   (nth
            morphetic-step-index
            (second (first states<-)))))
        (MNNs
         (if MNNs
           (add-to-list
            (- MNN-trans bass-step-MIDI) MNNs)))
        (MPNs
         (if MPNs
           (add-to-list
            (- MPN-trans bass-step-morphetic) MPNs))))
  (if (null states<-) ()
    (append
     (create-MIDI&morphetic-numbers<-
      (rest states<-)
      (if MNNs (first MNNs) (identity next-MIDI))
      (if MPNs
        (first MPNs) (identity next-morphetic))
      MIDI-step-index morphetic-step-index)
     (list
      (list
       (list
        (first (first (first states<-))) MNNs MPNs)
       (second (first states<-)))))))

#|
\noindent Example:
\begin{verbatim}
(setq 
 states<-
 '(((3 NIL) (NIL NIL "C-6-2" ((285 61 60 3 0 288 6))))
   ((2 (5 3 9))
    (17 10 "C-6-2"
     ((58 56 57 1 1 59 219) (58 61 60 1 1 59 220)
      (58 64 62 1 1 59 221)
      (58 73 67 3/2 0 119/2 222))))
   ((3/2 (3 9 14))
    (7 4 "C-7-2"
     ((120 50 54 1 1 121 351) (120 53 56 1 1 121 352)
      (120 62 61 1 1 121 353)
      (241/2 76 69 1/2 0 121 355))))
   ((1 (3 9 15))
    (0 0 "C-7-2"
     ((120 50 54 1 1 121 351) (120 53 56 1 1 121 352)
      (120 62 61 1 1 121 353)
      (120 77 70 1/2 0 241/2 354))))
   ((7/2 (3 6 15))
    (-2 -1 "C-7-2"
     ((119 52 55 1 1 120 346) (119 55 57 1 1 120 347)
      (119 61 60 1 1 120 348)
      (239/2 76 69 1/2 0 120 350))))))
(states2datapoints-by-lookup<- states<- 3 57 58)
--> ((0 35 45 1/2 1) (0 38 47 1/2 1) (0 44 50 1/2 1)
     (0 59 59 1/2 0) (1/2 33 44 1 1) (1/2 36 46 1 1)
     (1/2 45 51 2 1) (1/2 60 60 1/2 0) (1 59 59 1/2 0)
     (3/2 40 48 1 1) (3/2 48 53 1 1) (3/2 57 58 4 0)).
\end{verbatim}

This function is very similar to the function
states2datapoints-by-lookup. It applies the function
half-state2datapoint-by-lookup recursively to a list
of states generated by a backward-running Markov
model. |#

(defun states2datapoints-by-lookup<-
       (states<- &optional (beats-in-bar 4)
        (initial-MNN 60) (initial-MPN 60)
        (half-states->
         (create-MIDI&morphetic-numbers<-
          states<- initial-MNN initial-MPN))
        (j 0) (n (length half-states->))
        (state-durs
         (state-durations-by-beat
          (reverse states<-) beats-in-bar))
        (unique-times
         (cons
          0 (fibonacci-list state-durs))))
  (if (equal j n) ()
    (append
     (half-state2datapoints-by-lookup
      j half-states-> state-durs unique-times)
     (states2datapoints-by-lookup<-
      states<- beats-in-bar initial-MNN initial-MPN
      half-states-> (+ j 1) n state-durs
      unique-times))))
